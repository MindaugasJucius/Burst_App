//
//  LaunchscreenView.swift
//  Burst
//
//  Generated by PaintCode Plugin for Sketch
//  http://www.paintcodeapp.com/sketch
//

import UIKit

class LaunchscreenView: UIView {
    
    private var pointScaleFactor: CGPoint = CGPoint.zero
    private var animatableLayer: CAGradientLayer?
    
    private let gradientStartColors = [UIColor(hue: 0.582, saturation: 0.676, brightness: 0.992, alpha: 1).cgColor,
                                       UIColor(hue: 0.582, saturation: 1, brightness: 0.748, alpha: 1).cgColor,
                                       UIColor(hue: 0.975, saturation: 1, brightness: 1, alpha: 1).cgColor]
    private let gradientEndColors = [UIColor(hue: 0.975, saturation: 1, brightness: 1, alpha: 1).cgColor,
                                     UIColor(hue: 0.582, saturation: 1, brightness: 0.748, alpha: 1).cgColor,
                                     UIColor(hue: 0.582, saturation: 0.676, brightness: 0.992, alpha: 1).cgColor]
    
    override init(frame: CGRect) {
        super.init(frame: frame)
        backgroundColor = AppAppearance.lightBlack
    }
    
    required init?(coder aDecoder: NSCoder) {
        fatalError()
    }
    
    override func draw(_ rect: CGRect) {
        super.draw(rect)
        let shapeLayer = CAShapeLayer()
        let path = launchscreenBezierPath(forFrame: frame)
        shapeLayer.path = path.cgPath
        shapeLayer.strokeColor = UIColor.black.cgColor
        shapeLayer.lineWidth = 2
        let gradientLayer = CAGradientLayer()
        gradientLayer.colors = gradientStartColors
        gradientLayer.locations = [0.0, 0.48, 1.0]
        let origin = scale(point: CGPoint(x: 108, y: 174))
        gradientLayer.frame = CGRect(origin: origin, size: path.bounds.size)
        gradientLayer.mask = shapeLayer
        gradientLayer.startPoint = CGPoint(x: 1, y: 0.5)
        gradientLayer.endPoint = CGPoint(x: 0, y: 0.5)
        layer.addSublayer(gradientLayer)
        animatableLayer = gradientLayer
    }
    
    func animateGradient() {
        let colorChangeAnimation = CABasicAnimation(keyPath: "colors")
        colorChangeAnimation.duration = 2
        colorChangeAnimation.toValue = gradientEndColors
        colorChangeAnimation.autoreverses = true
        colorChangeAnimation.repeatCount = .infinity
        colorChangeAnimation.timingFunction = CAMediaTimingFunction(name: kCAMediaTimingFunctionEaseInEaseOut)
        animatableLayer?.add(colorChangeAnimation, forKey: "colorChange")
    }
    
    private func scale(point: CGPoint) -> CGPoint {
        return CGPoint(x: point.x * pointScaleFactor.x,
                       y: point.y * pointScaleFactor.y)
    }
    
    private func translate(point: CGPoint, byPoint: CGPoint = CGPoint.zero) -> CGPoint {
        return CGPoint(x: point.x + byPoint.x,
                       y: point.y + byPoint.y)
    }
    
    func launchscreenBezierPath(forFrame targetFrame: CGRect, resizing: ResizingBehavior = .aspectFit) -> UIBezierPath {
        let resizedFrame = resizing.apply(rect: CGRect(x: 0, y: 0, width: 375, height: 667), target: targetFrame)
        pointScaleFactor = CGPoint(x: resizedFrame.width / 375, y: resizedFrame.height / 667)
        let lineStartingPoint = CGPoint(x: 0.62, y: 158.89)
        let lineEndingPoint = CGPoint(x: 158.91, y: 0.9)
        let initialOffset = CGPoint(x: 0, y: 20)
        let path = UIBezierPath()
        
        for index in 0...8 {
            let line = UIBezierPath()
            let currentOffset = CGPoint(x: initialOffset.x, y: initialOffset.y * CGFloat(index))
            let fittingStartingPoint = scale(point: translate(point: lineStartingPoint, byPoint: currentOffset))
            let fittingEndingPoint = scale(point: translate(point: lineEndingPoint, byPoint: currentOffset))
            line.move(to: fittingStartingPoint)
            line.addLine(to: fittingEndingPoint)
            path.append(line)
        }
        
        return path
    }
    
    //MARK: - Resizing Behavior
    
    enum ResizingBehavior {
        case aspectFit /// The content is proportionally resized to fit into the target rectangle.
        case aspectFill /// The content is proportionally resized to completely fill the target rectangle.
        case stretch /// The content is stretched to match the entire target rectangle.
        case center /// The content is centered in the target rectangle, but it is NOT resized.
        
        func apply(rect: CGRect, target: CGRect) -> CGRect {
            if rect == target || target == CGRect.zero {
                return rect
            }
            
            var scales = CGSize.zero
            scales.width = abs(target.width / rect.width)
            scales.height = abs(target.height / rect.height)
            
            switch self {
            case .aspectFit:
                scales.width = min(scales.width, scales.height)
                scales.height = scales.width
            case .aspectFill:
                scales.width = max(scales.width, scales.height)
                scales.height = scales.width
            case .stretch:
                break
            case .center:
                scales.width = 1
                scales.height = 1
            }
            
            var result = rect.standardized
            result.size.width *= scales.width
            result.size.height *= scales.height
            result.origin.x = target.minX + (target.width - result.width) / 2
            result.origin.y = target.minY + (target.height - result.height) / 2
            return result
        }
    }

}
